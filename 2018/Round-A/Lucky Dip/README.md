# [Lucky Dip](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000050edf/0000000000050e1d)

## 题目描述  

一个袋子里有N个物品，对于每个物品i（0<= i < N）,其有价值Vi。现在你可以从袋子里随机取一件物品（取到每件物品的概率相同）  
然后，如果你对这件物品的价值不满意你可以将其放回，然后重新抽取。如果你满意了，也可以直接保留这件物品。现在允许你进行K次重新抽取，  
假设每次你都是按照最优策略来决定是否重新进行抽取的，求你所能获得的物品价值的期望。  

## 数据范围  

1 <= Vi <= 10^9
1 <= N <= 20000

## 解题步骤

* 1.排序
* 2.后缀和  
* 3.二分搜索  

## 分析

假设我们还剩下0次重新抽取的机会，这意味着我们无论这次抽到的物品是否满意，都必须保留这件物品。  
那么此时我们能获得物品价值的期望就是所有物品价值的平均值。记f(0) = mean。  
再考虑如果我们还剩1次重新抽取的机会，这时我已经知道了还剩0次重新抽取机会时所获得的价值期望f(0)。  
那么现在对于每一件物品，如果其价值大于等于f(0)，我就直接保留这件物品；否则的话，我就重抽。  
然而每件物品都进行这样的比较需要O(N)的复杂度，再加上K次重抽，复杂度就是O(KN)。  
我们可以先对物品价值按从小到大的顺序排序，然后利用lower_bound函数找到第一个价值大于等于f(0)的物品的位置，比如说是i。
那么下标在[0, i)的物品都是价值低于f(0)的，如果抽到它们，都要重抽的，这部分的期望为：prob * i * f(0)，其中prob = 1.0 / N为抽到每件物品的概率。  
然后下标在[i, N)的物品都是价值大于等于f(0)的，如果抽到它们，直接保留无须重抽。这部分的期望为prob * sum，其中sum是下标在[i,N)之间的物品价值之和。  
显然，如果事先求好物品价值数组的后缀和数组，那么sum可以直接查表得到，复杂度为O(1)。
利用上面的分析，我们递归求得每一次f(x)，然后返回f(K)即可。

## 复杂度

排序：O(NlogN)  
后缀和：预处理O(N)，查询O(1)  
二分搜索：O(logN)

总复杂度：O(NlogN) + O(N) + K * O(logN) = O((N + K)logN)
